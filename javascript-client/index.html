<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title>Request Queueing Pattern</title>
<script src="https://sdk.amazonaws.com/js/aws-sdk-2.0.0-rc.20.js"></script>
<script type="text/javascript">
/**
 * The following implementation of the RequestQueue Cloud Design Pattern on AWS SQS is based on
 * the AWS SQS API documented at:  http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/frames.html
 */
    // Assure the user associated with these credentials only has permission to create and read from
    // a temporary results queue and write to the Commands queue.
AWS.config.credentials = { accessKeyId: 'AKIAI3XYKLBZASDWM7DQ', secretAccessKey: '2COWQVUaxhqBTDtDRK5omHP0Shioo2G/e/M1I2bu' };
// Configure your region
AWS.config.region = 'us-west-2';
var sqs = new AWS.SQS();
var commandQueueUrl = "https://sqs.us-west-2.amazonaws.com/448119886995/Commands";
var resultQueueName;
var resultQueue;
var resultQueueURL;
var messagesSent = 0;
var messagesReceived = 0;

/**
 * Update the DOM to show we've successfully initialized.
 */
function renderInitialized() {
    document.getElementById('initializingMessage').hidden = true;
    document.getElementById('commandButtons').hidden = false;
}

/**
 * Show successful send results.
 */
function renderSendSuccess(command, sendResult) {
    var textArea = document.getElementById('commandsTextArea');
    textArea.value += '\r\nSent command:[' + command + '] in #' + sendResult.MessageId;
}

/**
 * Show successful receive results.
 */
function renderReceiveSuccess(messages) {
    var textArea = document.getElementById('resultsTextArea');
    for (var i = 0; i < messages.length; i++) {
        textArea.value += '\r\nResult ['+messages[i].Body+'] for #' + messages[i].MessageAttributes['InResponseTo'].StringValue;
    }
}

/**
 * Create a random queue name with enough bits as to be _extremely_ unlikely for collisions
 * A random number of 2^256 is generally accepted as suitably unlikely for a collision (e.g. Type4 UUID/GUID).
 * Given JavaScripts largest _integer_ is 2^53 - doing this 5 times will give use 2^265 (an extra 2^10). We represent
 * the result as a base 64 number encoded in the set of valid queue name characters. This will not exceed the
 * SQS Queue name character limit of 80 characters.
 *
 */
function generateUniqueResultQueueName() {
    var queueName = "Results_"; // 8
    var validChars = "0123456789abcdefghijklmnopqrstuvwqyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
    var radix = 64; // validChars.length;
    for (var i = 0; i < 5; i++) {
        var remainder = Math.floor(Math.random() * Math.pow(2, 53));
        for (var exponent = 8; exponent > 0; exponent--) {
            var base64 = Math.pow(radix, exponent);
            var digit = Math.floor(remainder / base64);
            queueName = queueName + validChars.substr(digit, 1);
            if (remainder > base64)
                remainder = remainder - (base64 * digit);
        }
        queueName = queueName + validChars.substr(remainder, 1);
    }
    return queueName;
}

/**
 *  Delete the Result Queue when we leave and it's no longer needed.
 *
 *  Because this can fail and we can't always assure clients will do this before disconnecting, a queue reaping
 *  function should be added to the compute node app to garbage collect queues over a certain age since last use.
 *
 *  Some applications may require longer lived queues and will need other means of either managing queue
 *  lifecycle, or use a shared queue and filtering messages for a specific user.
 */
function deleteResultQueueOnExit() {
    window.onunload = new function () {
        resultQueue.deleteQueue({ QueueUrl: resultQueueURL }, function (err, data) {
            if (err) console.log(err, err.stack); // an error occurred
            else     console.log(data);           // successful response
        })
    };
}

/**
 * Create a temporary queue to hold the results of our Commands.
 * We'll set the Queue to hold the connection for 1 second, and reconnect every 2.
 */
// TODO Move this to the CommandProcessors responsibility, reducing permissions required of clients
function createTemporaryResultQueue() {
    resultQueueName = generateUniqueResultQueueName();
    var params = {
      QueueName: resultQueueName,
      Attributes: {
          ReceiveMessageWaitTimeSeconds: "1"
      }
    };

    sqs.createQueue(params, function (err, data) {
        if (err) console.error(err);
        else if (data) {
            resultQueueURL = data.QueueUrl;
            resultQueue = new AWS.SQS({params: {QueueUrl: resultQueueURL}});
            renderInitialized();
        }
    });
}

/**
 * Remove messages that have been handled from the Results queue.
 */
function removeHandledMsgsFromQueue(msgsToRemove) {
    if (msgsToRemove.length > 0) {
        var entries = [];
        for (var i = 0; i < msgsToRemove.length; i++) {
            entries[i] = { Id: msgsToRemove[i].MessageId, ReceiptHandle: msgsToRemove[i].ReceiptHandle }
        }
        var params = {
            Entries: entries,
            QueueUrl: resultQueueURL
        };
        sqs.deleteMessageBatch(params, function (err, data) {
            if (err) console.log(err, err.stack); // an error occurred
            else     console.log(data);           // successful response
        });
    }
}

/**
 * Receive our results. This method assumes a result queue has been setup already.
 *
 * As a best practice, SQS should be setup for Long Polling as it is the most efficient polling implementation,
 * requiring the least number of http request/responses. This translates into not only reduced network usage by
 * client and server, but also fewer header parsings which is particularly costly to mobile device battery usage
 * and responsiveness.
 * See: http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-long-polling.html
 */
function receive() {
    var params = {
        QueueUrl: resultQueueURL,
        MaxNumberOfMessages: 10, // how many messages do we wanna retrieve?
        VisibilityTimeout: 60, // seconds - how long we want a lock on this job
        WaitTimeSeconds: 15, // seconds - how long should we wait for a message?
        MessageAttributeNames: [
            'InResponseTo'
          ]
    }
    resultQueue.receiveMessage(params, function (err, data) {
        if (err) console.error(err);
        else if (data) {
            renderReceiveSuccess(data.Messages);
            removeHandledMsgsFromQueue(data.Messages);
            messagesReceived += data.Messages.length;
            if (messagesReceived < messagesSent) receive();
        }
    });
}

/**
 * Send our Command request to an existing Requests queue 'repeat' number of times
 */
function send(command, repeat) {
    var commandQueue = new AWS.SQS({params: {QueueUrl: commandQueueUrl}});
    for (var i = 0; i < repeat; i++) {
        commandQueue.sendMessage(
                {   MessageBody: command,
                    MessageAttributes: {
                        ReplyTo: {
                            DataType: 'String',
                            StringValue: resultQueueName
                        }
                    }
                },
                function (err, data) {
                    if (err) console.error(err);
                    else renderSendSuccess(command, data);
                }
        );
    }
    messagesSent += repeat;
}

/**
 * Send the Command request then attempt to receive the results.
 */
function request(command, repeat) {
    send(command, repeat);
    receive();
}

createTemporaryResultQueue();

</script>
</head>
<body onunload="deleteResultQueueOnExit()">
<h3><a href="https://docs.google.com/document/d/1MZrJCoUmc-69QqXrt2PeeZaxpTkoDtrtK8OKusnJ36c/edit?usp=sharing">Request
        Queueing</a> on <a href="http://aws.amazon.com/sqs/">AWS SQS</a>.
</h3>
<p>
    This is an example of using the
    <a href="https://docs.google.com/document/d/1MZrJCoUmc-69QqXrt2PeeZaxpTkoDtrtK8OKusnJ36c/edit?usp=sharing">Request
    Queueing</a> Cloud Design Pattern.
</p>
<p>The idea is to asynchronously send commands to a request queue so that it can be handled by a scalable number of
    nodes (horizontal scaling). The results from all of the nodes are placed on a result queue (established by this
    client) which is polled, rendered and subsequently deleted by this client.
</p>

<p>
    The <a href="https://github.com/JaysonRaymond/request-queueing/blob/master/javascript-client/index.html">client
    implementation</a> uses the <a href="http://docs.aws.amazon.com/AWSJavaScriptSDK/guide/index.html">AWS SQS
    Javascript library</a> which allows desktop/settop/mobile browsers and hybrid applications to all directly access
    the SQS service without requiring an intermediate gateway.
</p>
<p>
    The backend
    <a href="https://github.com/JaysonRaymond/request-queueing/blob/master/command-processor/src/main/java/CommandProcessor.java">
    implementation of the Command Processor</a> leverages <a href="http://camel.apache.org/">Apache Camel</a> for its
    significant utility and can be run on <a href="http://aws.amazon.com/ec2/">EC2</a> or better yet,
    <a href="http://aws.amazon.com/elasticbeanstalk/">Elastic Beanstalk</a> instances.
</p>
<br>

<div id="initializingMessage">
    <br><br><br>
    <i>Attempting to setup an AWS SQS Queue for our results... (if this message persists, check the console for
        errors).</i>
</div>
<div id="commandButtons" hidden>
    Command to Request:
    <ul>
        <li>
            <button onclick="request('IP', 1)">Report the IP address of the compute node fulfilling the request</button>
            <button onclick="request('IP', 100)">100x</button>
        </li>
        <li>
            <button onclick="request('TIME', 1)">Report the time at which the Command was processed by a compute node</button>
            <button onclick="request('TIME', 100)">100x</button>
        </li>
    </ul>
    <textarea id="commandsTextArea" cols="53" rows="25" readonly></textarea>
    <textarea id="resultsTextArea" cols="70" rows="25" readonly></textarea>
</div>
<br>
</body>
</html>