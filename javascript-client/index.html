<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title>Request Queueing Pattern</title>
<script src="https://sdk.amazonaws.com/js/aws-sdk-2.0.0-rc.20.js"></script>
<script type="text/javascript">
/**
 * The following implementation of the RequestQueue Cloud Architectural Design Pattern on AWS SQS is based on
 * the AWS SQS API documented at:  http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/frames.html
 */
    // Assure the user associated with these credentials only has permission to create and read from
    // a temporary results queue and write to the Commands queue.
AWS.config.credentials = { accessKeyId: 'AKIAI3XYKLBZASDWM7DQ', secretAccessKey: '2COWQVUaxhqBTDtDRK5omHP0Shioo2G/e/M1I2bu' };
// Configure your region
AWS.config.region = 'us-west-2';
var sqs = new AWS.SQS();
var commandQueueUrl = "https://sqs.us-west-2.amazonaws.com/448119886995/Commands";
var resultQueueName;
var resultQueue;
var resultQueueURL;
var messagesSent = 0;
var messagesReceived = 0;

/**
 * Update the DOM to show we've successfully initialized.
 */
function renderInitialized() {
    document.getElementById('initializingMessage').hidden = true;
    document.getElementById('commandButtons').hidden = false;
}

/**
 * Show successful send results.
 */
function renderSendSuccess(command, sendResult) {
    var textArea = document.getElementById('commandsTextArea');
    textArea.value += '\r\nSent command:[' + command + '] in message#' + sendResult.MessageId;
}

/**
 * Show successful receive results.
 */
function renderReceiveSuccess(messages) {
//            data (Object) — the de-serialized data returned from the request. Set to null if a request error occurs. The data object has the following properties:
//            Messages — (Array<map>)
//            A list of messages.
//
//            MessageId — (String)
//            A unique identifier for the message. Message IDs are considered unique across all AWS accounts for an extended period of time.
//
//            ReceiptHandle — (String)
//            An identifier associated with the act of receiving the message. A new receipt handle is returned every time you receive a message. When deleting a message, you provide the last received receipt handle to delete the message.
//
//            MD5OfBody — (String)
//            An MD5 digest of the non-URL-encoded message body string.
//
//            Body — (String)
//            The message's contents (not URL-encoded).
//
//            Attributes — (map<String>)
//            SenderId, SentTimestamp, ApproximateReceiveCount, and/or ApproximateFirstReceiveTimestamp. SentTimestamp and ApproximateFirstReceiveTimestamp are each returned as an integer representing the epoch time in milliseconds.
//
//            MD5OfMessageAttributes — (String)
//            An MD5 digest of the non-URL-encoded message attribute string. This can be used to verify that Amazon SQS received the message correctly. Amazon SQS first URL decodes the message before creating the MD5 digest. For information about MD5, go to http://www.faqs.org/rfcs/rfc1321.html.
//
//            MessageAttributes — (map<map>)
//            Each message attribute consists of a Name, Type, and Value. For more information, see Message Attribute Items.
//
//            StringValue — (String)
//            Strings are Unicode with UTF8 binary encoding. For a list of code values, see http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters.
//
//            BinaryValue — (Buffer, Typed Array, Blob, String)
//            Binary type attributes can store any binary data, for example, compressed data, encrypted data, or images.
//
//            StringListValues — (Array<String>)
//            Not implemented. Reserved for future use.
//
//            BinaryListValues — (Array<Buffer, Typed Array, Blob, String>)
//            Not implemented. Reserved for future use.
//
//            DataType — required — (String)
//            Amazon SQS supports the following logical data types: String, Number, and Binary. In addition, you can append your own custom labels. For more information, see Message Attribute Data Types.
//

    var textArea = document.getElementById('resultsTextArea');
    for (var i = 0; i < messages.length; i++) {
        textArea.value += '\r\nResult ['+messages[i].Body+'] for command in message#' + messages[i].MessageId;
    }
}

/**
 * Create a random queue name with enough bits as to be _extremely_ unlikely for collisions
 * A random number of 2^256 is generally accepted as suitably unlikely for a collision (e.g. Type4 UUID/GUID).
 * Given JavaScripts largest _integer_ is 2^53 - doing this 5 times will give use 2^265 (an extra 2^10). We represent
 * the result as a base 64 number encoded in the set of valid queue name characters. This will not exceed the
 * SQS Queue name character limit of 80 characters.
 *
 */
function generateUniqueResultQueueName() {
    var queueName = "Results_"; // 8
    var validChars = "0123456789abcdefghijklmnopqrstuvwqyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
    var radix = 64; // validChars.length;
    for (var i = 0; i < 5; i++) {
        var remainder = Math.floor(Math.random() * Math.pow(2, 53));
        for (var exponent = 8; exponent > 0; exponent--) {
            var base64 = Math.pow(radix, exponent);
            var digit = Math.floor(remainder / base64);
            queueName = queueName + validChars.substr(digit, 1);
            if (remainder > base64)
                remainder = remainder - (base64 * digit);
        }
        queueName = queueName + validChars.substr(remainder, 1);
    }
    return queueName;
}

/**
 *  Delete the Result Queue when we leave and it's no longer needed.
 *
 *  Because this can fail and we can't always assure clients will do this before disconnecting, a queue reaping
 *  function should be added to the compute node app to garbage collect queues over a certain age since last use.
 *
 *  Some applications may require longer lived queues and will need other means of either managing queue
 *  lifecycle, or use a shared queue and filtering messages for a specific user.
 */
function deleteResultQueueOnExit() {
    window.onunload = new function () {
        resultQueue.deleteQueue({ QueueUrl: resultQueueURL }, function (err, data) {
            if (err) console.log(err, err.stack); // an error occurred
            else     console.log(data);           // successful response
        })
    };
}

/**
 * Create a temporary queue to hold the results of our Commands.
 * We'll set the Queue to hold the connection for 1 second, and reconnect every 2.
 */
function createTemporaryResultQueue() {
    resultQueueName = generateUniqueResultQueueName();
    var params = {
      QueueName: resultQueueName,
      Attributes: {
          ReceiveMessageWaitTimeSeconds: "1"
      }
    };

    sqs.createQueue(params, function (err, data) {
        if (err) console.error(err);
        else if (data) {
            resultQueueURL = data.QueueUrl;
            resultQueue = new AWS.SQS({params: {QueueUrl: resultQueueURL}});
            renderInitialized();
        }
    });
}

/**
 * Remove messages that have been handled from the Results queue.
 */
function removeHandledMsgsFromQueue(msgsToRemove) {
    if (msgsToRemove.length > 0) {
        var entries = [];
        for (var i = 0; i < msgsToRemove.length; i++) {
            entries[i] = { Id: msgsToRemove[i].MessageId, ReceiptHandle: msgsToRemove[i].ReceiptHandle }
        }
        var params = {
            Entries: entries,
            QueueUrl: resultQueueURL
        };
        sqs.deleteMessageBatch(params, function (err, data) {
            if (err) console.log(err, err.stack); // an error occurred
            else     console.log(data);           // successful response
        });
    }
}

/**
 * Receive our results. This method assumes a result queue has been setup already.
 *
 * As a best practice, SQS should be setup for Long Polling as it is the most efficient polling implementation,
 * requiring the least number of http request/responses. This translates into not only reduced network usage by
 * client and server, but also fewer header parsings which is particularly costly to mobile device battery usage
 * and responsiveness.
 * See: http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-long-polling.html
 */
function receive() {
    var params = {
        QueueUrl: resultQueueURL,
        MaxNumberOfMessages: 10, // how many messages do we wanna retrieve?
        VisibilityTimeout: 60, // seconds - how long we want a lock on this job
        WaitTimeSeconds: 15 // seconds - how long should we wait for a message?
    }
    resultQueue.receiveMessage(params, function (err, data) {
        if (err) console.error(err);
        else if (data) {
            renderReceiveSuccess(data.Messages);
            removeHandledMsgsFromQueue(data.Messages);
            messagesReceived += data.Messages.length;
            if (messagesReceived < messagesSent) receive();
        }
    });
}

/**
 * Send our Command request to an existing Requests queue 'repeat' number of times
 */
function send(command, repeat) {
    var commandQueue = new AWS.SQS({params: {QueueUrl: commandQueueUrl}});
    for (var i = 0; i < repeat; i++) {
        commandQueue.sendMessage(
                {   MessageBody: command,
                    MessageAttributes: {
                        ReplyTo: {
                            DataType: 'String',
                            StringValue: resultQueueName
                        }
                    }
                },
                function (err, data) {
                    if (err) console.error(err);
                    else renderSendSuccess(command, data);
                }
        );
    }
    messagesSent += repeat;
}

/**
 * Send the Command request then attempt to receive the results.
 */
function request(command, repeat) {
    send(command, repeat);
    receive();
}

createTemporaryResultQueue();

</script>
</head>
<body onunload="deleteResultQueueOnExit()">
<h3> This is an example of the
    <a href="https://docs.google.com/document/d/1MZrJCoUmc-69QqXrt2PeeZaxpTkoDtrtK8OKusnJ36c/edit?usp=sharing">Request
        Queueing Command Pattern</a> implemented on <a href="http://aws.amazon.com/sqs/">AWS SQS</a>.
</h3>

<p>The idea is to asynchronously send commands to a request queue so that it can be handled by a scalable number of
    nodes (horizontal scaling). The results from all of the nodes are placed on a result queue (established by this
    client) which is polled, rendered and subsequently deleted by this client.
</p>

<p>
    This implementation uses the <a href="http://docs.aws.amazon.com/AWSJavaScriptSDK/guide/index.html">AWS SQS
    Javascript
    library</a> which allows desktop/settop/mobile browsers and hybrid applications to all directly access the SQS
    service without requiring an intermediate gateway.
</p>
<br>

<div id="initializingMessage">
    <br><br><br>
    <i>Attempting to setup an AWS SQS Queue for our results... (if this message persists, check the console for
        errors).</i>
</div>
<div id="commandButtons" hidden>
    Command to Request:
    <ul>
        <li>
            <button onclick="request('TIME', 1)">Report the time at which the Command was processed by a compute node
            </button>
            <button onclick="request('TIME', 100)">100x</button>
        </li>
        <li>
            <button onclick="request('IP', 1)">Report the IP address of the compute node fulfilling the request</button>
            <button onclick="request('IP', 100)">100x</button>
        </li>
    </ul>
    <textarea id="commandsTextArea" cols="64" rows="25" readonly></textarea>
    <textarea id="resultsTextArea" cols="64" rows="25" readonly></textarea>
</div>
<br>
</body>
</html>